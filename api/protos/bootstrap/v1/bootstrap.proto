syntax = "proto3";

package bootstrap;
option go_package = "bootstrap/v1;bootstrapv1";

import "google/protobuf/duration.proto";
import "validate/validate.proto";


// [#next-free-field: 7]
message Bootstrap {
    // xds-relay server configuration.
    Server server = 1 [(validate.rules).message.required = true];

    // Configuration information about the origin server.
    Upstream origin_server = 2 [(validate.rules).message.required = true];

    // Logging settings.
    Logging logging = 3 [(validate.rules).message.required = true];

    // Request/response cache settings.
    Cache cache = 4 [(validate.rules).message.required = true];

    // Metrics sink settings
    MetricsSink metrics_sink = 5 [(validate.rules).message.required = true];

    // Admin server configuration.
    Admin admin = 6 [(validate.rules).message.required = true];
}

// [#next-free-field: 2]
message Server {
    // The TCP address that the xds-relay server will listen on.
    SocketAddress address = 1 [(validate.rules).message.required = true];
}

// [#next-free-field: 5]
message Upstream {
    // The address for the upstream cluster.
    SocketAddress address = 1 [(validate.rules).message.required = true];

    // grpc connection keep alive time backed by https://github.com/grpc/grpc-go/blob/v1.32.0/keepalive/keepalive.go#L34-L37
    // If unset defaults to 5 minutes.
    // Usage example: 2m to represent 2 minutes
    // Reason for not using google.protobuf.Duration
    // keepalive will be in minutes or possibly hours.
    // From https://developers.google.com/protocol-buffers/docs/reference/java/com/google/protobuf/Duration
    // Duration only lets us represent time in 's'
    string keep_alive_time = 2;

    // Timeout for upstream connection stream.
    // If unset defaults to no timeout.
    // A new stream will be opened (retried) after the timeout is hit.
    // Usage example: 2m to represent 2 minutes.
    string stream_timeout = 3;

    // Jitter for upstream connection stream timeouts. Used with timeout to reset streams without overloading
    // the upstream server. Jitter is the upper tolerance for random variation in the timeout. e.g. timeout=15s,
    // jitter=5s -> stream timeout is a random value between 15s and 20s.
    // If unset defaults to no jitter.
    string stream_timeout_jitter = 4;

    // Optional. Maximum timeout for blocked gRPC sends.
    // If this timeout is reached, the stream will be disconnected and re-opened.
    //
    // The value of gRPC send timeout is generally,
    // min(stream_timeout - stream_open_duration, stream_send_max_timeout)
    //
    // A stream_send_min_timeout buffer is added for short final send timeout values to prevent
    // scenarios where the stream deadline is reached too quickly. The complete accuracy of the
    // value is therefore,
    // stream send timeout = max(stream_send_min_timeout, min(stream_timeout - stream_open_duration, stream_send_max_timeout))
    //
    // If unset, the stream_timeout value is used.
    //
    // Examples:
    //
    // Ex 1:
    //   stream_timeout = 15m
    //   stream_send_max_timeout = 5m
    //   stream_send_min_timeout = 1m
    //   ... 1m in send blocks
    //       final send timeout = max(1m, min(15m - 1m, 5m)) = 5m
    //   ... 11m in send blocks
    //       final send timeout = max(1m, min(15m - 11m, 5m)) = 4m
    //   ... 14.5m in send blocks
    //       A 1m buffer is added for short final send timeout values to prevent scenarios where
    //       the stream deadline is reached too quickly.
    //       final send timeout = max(1m, min(15m - 14.5m, 5m)) = 1m
    //
    // Ex 2:
    //   stream_timeout = 5m
    //   stream_send_max_timeout = 10m
    //   stream_send_min_timeout = "" // not configured
    //   ... 1m in send blocks
    //       final send timeout = min(5m - 1m, 10m) = 4m
    //   ... 4m in send blocks
    //       final send timeout = min(5m - 4m, 10m) = 1m
    //   ... > 5m in send blocks will never occur because of the 5m stream timeout
    //
    // Ex 3:
    //   stream_timeout = "" // not configured
    //   stream_send_max_timeout = 5m
    //   stream_send_min_timeout = 4m
    //   ... in all send block scenarios,
    //       final send timeout = max(4m, 5m) = 5m
    //
    // Ex 4:
    //   stream_timeout = 10m
    //   stream_send_max_timeout = "" // not configured
    //   stream_send_min_timeout = 1m
    //   ... in all send block scenarios,
    //       final send timeout = max(1m, 10m) = 10m
    //
    string stream_send_max_timeout = 5;

    // Optional. Used in conjunction with stream_send_max_timeout.
    // Refer to document for stream_send_max_timeout.
    // This value must not be > stream_send_max_timeout. Server enforced.
    string stream_send_min_timeout = 6;

    // Optional. Maximum timeout for blocked gRPC recvs.
    // If this timeout is reached, a NACK will be sent to the upstream server with the same
    // version and nounce as the prior attempted send.
    //
    // The value of gRPC recv timeout is generally,
    // min(stream_timeout - stream_open_duration, stream_recv_max_timeout)
    //
    // A stream_recv_min_timeout buffer is added for short final recv timeout values to prevent
    // scenarios where the stream deadline is reached too quickly. The complete accuracy of the
    // value is therefore,
    // stream recv timeout = max(stream_recv_min_timeout, min(stream_timeout - stream_open_duration, stream_recv_max_timeout))
    //
    // If unset, the stream_timeout value is used.
    //
    // Please refer to stream_send_max_timeout for examples, replacing send with recv.
    string stream_recv_max_timeout = 7;

    // Optional. Used in conjunction with stream_recv_max_timeout.
    // Refer to document for stream_recv_max_timeout.
    // This value must not be > stream_recv_max_timeout. Server enforced.
    string stream_recv_min_timeout = 8;
}

// [#next-free-field: 3]
message Logging {
    // Filepath where logs are emitted. If no filepath is specified, logs will be written to stderr.
    string path = 1;

    // The logging level. If no logging level is set, the default is INFO.
    enum Level {
        INFO = 0;
        DEBUG = 1;
        WARN = 2;
        ERROR = 3;
    }
    Level level = 2 [(validate.rules).enum.defined_only = true];
}

// [#next-free-field: 3]
message Cache {
    // Duration before which a key is evicted from the request/response cache. Zero means no expiration time.
    google.protobuf.Duration ttl = 1 [(validate.rules).duration = {required: true, gte: {nanos: 0}}];

    // The maximum number of keys allowed in the request/response cache. If unset, no maximum number will be enforced.
    int32 max_entries = 2;
}

// [#next-free-field: 3]
message SocketAddress {
    // The address for this socket. Listeners will bind to the address.
    string address = 1 [(validate.rules).string = {address: true}];

    uint32 port_value = 2 [(validate.rules).uint32 = {lte: 65535}];
}

// [#next-free-field: 2]
message Admin {
    // The TCP address that the admin server will listen on.
    SocketAddress address = 1 [(validate.rules).message.required = true];
}

// The type of metrics sink, i.e. statsd, prometheus, etc.
message MetricsSink {
    oneof type {
      option (validate.required) = true;

      Statsd statsd = 1;
    }
}

// [#next-free-field: 4]
message Statsd {
    SocketAddress address = 1 [(validate.rules).message.required = true];

    string root_prefix = 2 [(validate.rules).string.min_bytes = 1];

    google.protobuf.Duration flush_interval = 3 [(validate.rules).duration = {required: true, gte: {nanos: 0}}];
}
